## 当前实现的问题

现有结构只保存分支的后续消息，不保存分叉点本身的快照。

分叉点被修改后，所有分支都会显示最新内容，无法还原。

要支持完整还原，需在每个分支里保存分叉点的快照。

## 为什么会有这种现象？

你的理解是对的，这种 " 切换分支后，原本的消息内容被修改，导致无法切回原来的分支内容 " 的问题，**本质上是数据结构和分支切换实现方式导致的**。下面详细解释原因：

---

### 1. 当前数据结构的核心特点

- `messageForksHash` 只记录了**被分叉消息之后的消息分支**（即 " 分支的后续消息 "），**并不保存被分叉那条消息本身的内容快照**。
- 主消息流（`Session.messages`）中，被分叉的那条消息（比如 `msg123`）始终只有一份，是 " 当前版本 "。
- 切换分支时，**只会替换被分叉消息之后的消息内容**，不会还原被分叉消息本身的内容。

---

### 2. 具体流程举例

1. 你有一条消息 `msg123`，内容为 " 你好 "。
2. 你生成了两个分支（fork），每个分支下有不同的后续消息。
3. 你在主消息流里把 `msg123` 的内容改成了 "hello world"。
4. 这时无论你怎么切换分支，**`msg123` 的内容都是 "hello world"**，而不是原来分支时的 " 你好 "。

---

### 3. 为什么会这样？

#### 数据结构决定

- `messageForksHash` 的 `lists` 只保存了**分支的后续消息**，**没有保存分叉点（即被分叉消息）本身的内容快照**。
- 切换分支时，代码逻辑是：
  - 找到分叉点（`msg123`）在主消息流的位置。
  - 用分支的后续消息替换主消息流中分叉点之后的内容。
  - **分叉点本身不会被还原或替换**，始终是主消息流当前的内容。

#### 设计初衷

- 这样设计可以节省存储空间，避免每个分支都冗余存储分叉点之前的所有消息。
- 但缺点是：**分叉点本身如果被修改，所有分支都会受到影响，无法还原到分支创建时的状态**。

---

### 4. 解决思路

如果你希望切换分支时，**分叉点本身的内容也能还原**，需要在数据结构上做如下改进：

- 在 `messageForksHash` 的每个分支（`lists`）里，**不仅保存后续消息，还要保存分叉点本身的快照**。
- 或者每个分支都保存 " 分叉点及其之后的完整消息快照 "。
- 切换分支时，把分叉点及其后续消息一起还原。

**伪代码结构示例：**

```ts
messageForksHash: {
  [messageId: string]: {
    position: number,
    lists: [
      {
        id: string,
        forkMessage: Message,      // 分叉点的快照
        messages: Message[],       // 分支的后续消息
      }
    ],
    createdAt: number
  }
}
```

切换分支时，把 `forkMessage` 和 `messages` 一起还原到主消息流。

---

## 初步修改方法

### 初步解决

- 现在的实现就是在每个分支的结构里加了一个 forkMessage 字段，专门保存分叉点的快照。
- 切换分支时，把 forkMessage 和分支下方的 messages 一起拼接到主消息流里。
- 这样每个分支都能还原自己的分叉点内容和分支消息。

### 1. 之前的流程（未保存 fork 点快照时）

#### 1.1 分叉时

- 你在某个消息 A（分叉点）分叉。
- 把 A 之后的所有消息（比如 B、C）保存到 `messageForksHash[A].lists[position].messages`。
- **A 本身（分叉点）并没有保存快照**，只是主消息流里的 A。

#### 1.2 修改 fork 点

- 你编辑了 A（分叉点），主消息流里的 A 内容发生了变化。
- 由于 `messageForksHash` 只保存了 A 之后的消息（B、C），**没有保存 A 的历史内容**。

#### 1.3 切换分支

- 切换分支时，代码会这样拼接消息流：

  ```ts
  data = data.slice(0, forkMessageIndex + 1).concat(forks.lists[newPosition].messages)
  ```

- 也就是说，**分叉点 A 用的还是主消息流里的 A**，后面拼接的是分支下方的消息。
- 如果 A 被修改过，所有分支切换时看到的 A 都是 " 最新的 A"，**无法还原分叉时的 A**。

---

### 2. 现在的流程（保存 fork 点快照后）

#### 2.1 分叉时

- 除了保存 A 之后的消息，还用 `deepClone` 保存了 A 的快照到 `forkMessage`。
- 每个分支都保存了自己的分叉点快照。

#### 2.2 修改 fork 点

- 你编辑主消息流里的 A，不会影响各分支保存的 `forkMessage`。

#### 2.3 切换分支

- 切换分支时，代码这样拼接消息流：

  ```ts
  data = data.slice(0, forkMessageIndex).concat(forks.lists[newPosition].forkMessage, forks.lists[newPosition].messages)
  ```

- 这样分叉点 A 用的是分支自己的快照，**每个分支都能还原分叉时的 A**。

---

### 3. 为什么之前切换分支不会复原 fork 点？

- 因为**之前没有保存 fork 点的快照**，切换分支时只能用主消息流里的 A。
- 如果 A 被修改过，所有分支看到的 A 都是被修改后的内容，历史被污染。
- 只有保存了快照，切换分支时才能还原每个分支自己的 A。

---

### 4. 总结

- **之前流程**：只保存分叉点之后的消息，分叉点本身用主消息流里的内容，切换分支无法还原分叉时的 A。
- **现在流程**：每个分支都保存分叉点快照，切换分支时用快照还原，历史一致性更好。

---

如果你还想看具体的代码流程或有更细节的疑问，欢迎继续追问！

### 问题

仍然有问题，更新的时候，A1，A2，A1.1，A2，A1（不对）。但是我现在保存 A1.1 之后切换到 A2 再切换回 A1.1，显示的却是 A1.0，为什么呀，你能帮我看看代码吗

- 编辑分叉点时，分支快照没有同步更新。
- 切换分支时，主消息流被分支快照覆盖，导致编辑内容丢失。
解决不彻底，因为新加了数据结构，而且深度克隆不太好，有更新需求，更新不方便。能不能找一种维持原有解决方案的办法？

而且为什么会导致这种问题呢？

session 结构和 message 结构设计分析。

那从理论上讲，如果我多保存一个，把 A1 也保存了，那么 A2 在切换回 A1 的时候是不是就会在切换 B1C1 的同时把 A1 切换回来？这是不是另一种解决问题的方式呢？

## 兼容原有数据结构的新设计

- **分支的归属**：

原来是 "B1 这条消息有分支 "，现在变成 "B1 的上一个消息 A 下面有分支 "。

- **分支内容**：

A 的分支列表里保存了所有以 A 为父节点的分支（如 B1、B2），每个分支都是一条独立的消息链。

- **兼容性**：

messageForksHash 依然是 session 级别的，只是 key 变成 " 分支的父消息 id"（即 A 的 id），value 是所有分支的列表（B1、B2…）。

这样可以

- **兼容原有的 session/messageForksHash 设计**，不需要把消息结构改成树。
- **分支的入口清晰**，每个分支的第一个消息就是 fork 时新建的消息。
- **分支切换逻辑清楚**，只需在父消息（A）下切换不同分支即可。

### 问题

- 它有一个向下生成回复的功能，插入一条新信息。如果我在 A 中保存了分支信息，本来应该渲染到 B 上，但是突然插入了一个 Aa。那么就会错误的渲染到 Aa 上。
- 其实理论上，现在的设计是 A 保存 B 的所有分支信息。但是 A 没有和 B 建立联系，只是简单的用 index 来识别下一条消息的分支。这样设计很不好。
- 向下生成插入了一个新信息，我觉得这个一点用都没有。如果自己用完全可以删除掉。
